/****************************************************************************************/
/********************************** Course:   Stat 2509        **************************/
/********************************** Project:  Lecture-1        **************************/ 
/********************************** Author:   Dr. Fares Said   **************************/ 
/********************************** Date: 	  Sept 2019        **************************/ 
/****************************************************************************************/

/****************************************************************************************/
/********************************** Example 3.1: in Lecture-1 ***************************/ 
/****************************************************************************************/

FOOTNOTE1 "Course: STAT 2509; Lecture 1 SLR"; 
FOOTNOTE2 "Student Name: Your Name; Student ID: 124563998"; 

/* Data from a sample of 10 pharmacies are used to examine the relation between 
prescription sales volume and the percentage of prescription ingredients purchased 
directly from the supplier. */ 

/* 	Find the LSE for the regression line Y = B0 + B1X. 
	
	Plot the (X, Y) data and the prediction equation.
	
	Find the correlation coefficient. 
	
	Predict sales volume for a pharmacy that purchases 15% of its prescription ingredients
	directly from the supplier. What about 18%? 
*/ 

/* First, we create the dataset in SAS. Note that this gets created to the WORK library
(temporary). */ 
DATA sale; 
	ATTRIB ID LABEL = "Pharmacy"; 
	ATTRIB Y LABEL = "Sale Volume in $1000"; 
	ATTRIB X LABEL = "% of Ingredients Purchased Directly"; 
	INPUT ID Y X; 
	DATALINES; 
	1 25 10
	2 55 18
	3 50 25
	4 75 40
	5 110 50
	6 138 63
	7 90 42
	8 60 30
	9 10 5
	10 100 55
	; 
RUN; 

/* To find the LSE and create the necessary plots, we can use the REG procedure. */ 
/* Note: The following will NOT work in the University Edition of SAS! */ 
PROC REG DATA = work.sale;
	MODEL Y = X;						/*  / LACKFIT; */
	PLOT Y * X = "*"; 					/* Scatterplot for Y vs X */ 
	PLOT RESIDUAL. * PREDICTED. = "*";	/* Scatterplot for error vs. fitted */ 
	PLOT RESIDUAL. * OBS. = "*"; 		/* Scatterplot for error vs observation number */
	/* Save the Residuals and Fitted into a new data table called OutReg: */ 
	OUTPUT OUT = OutReg RESIDUAL = Residual PREDICTED = Fitted;
RUN; 

/* 	Interpreting (some of) the output from the above REG procedure: 
 	Significant F statistic => A significant portion of the variation is explained by the model. 
	Model df = One less than the number of parameters =>  2 - 1 = 1
	Corrected total df = One less than the number of observations => 10 - 1 = 9
	LSE of B0: 4.69785; SE of this estimate: 5.95202; high p-val => not significantly different from 0	 
	LSE of B1: 1.97408; SE of this estimate: 0.15455; low p-val => significantly different from 0 

	Interpreting (some of) the generated plots from the above REG procedure: 
	The plot of Y vs. X plots the (X, Y) points along with the regression line Y = B0 + B1X
	Assumption of SLR: All errors have same variance => Residual plots 
*/

/* 	If you're using the University Edition, the following will produce the same 
	plots of interest: 

ODS GRAPHICS ON;
PROC REG DATA = work.sale;
	MODEL Y = X; 
	/* Save the Residuals and Fitted into a new data table called OutReg: 
	OUTPUT OUT = OutReg RESIDUAL = Residual PREDICTED = Fitted;
RUN; 
ODS GRAPHICS OFF;

*/

/* To find the correlation coefficient, we use the CORR procedure: */ 
PROC CORR DATA = work.sale;
	VAR X Y; 
RUN; 
/* Therefore, the correlation coefficient is: 0.97627 */

/* Another way to check the Normality assumption is by using the CHART procedure: */ 
PROC CHART DATA = OutReg; 
	VBAR Residual;
RUN; 
/* We see (very roughly) that the errors are distributed approx. Normally */ 

/* 	Predict values: Find CI and PI 
 	Let's predict the value of Y when X = 15 and when X = 18
 	To do this: create a new data table called To_Predict; fill it with the work.sales table 
	Then, add two new rows: one for X = 15, and one for X = 18. This will give us rows 11 and 12.
*/ 
PROC SQL;
	CREATE TABLE To_Predict AS 
		SELECT *
		FROM Sale;
	INSERT INTO To_Predict
		VALUES (11, ., 15)
		VALUES (12, ., 18);
QUIT;

/* 	Now we find the CI and PI.
  	CLI will compute (1-alpha)*100% PI for an individual predicted value
  	CLM will compute (1-alpha)*100* CI for E[X]
  	Then save the results into the OutReg data table 
*/ 
PROC REG DATA = work.To_Predict ALPHA = 0.01;
	MODEL Y = X / CLI CLM; */LACKFIT;
	OUTPUT OUT = OutReg RESIDUAL = Residual PREDICTED = Fitted LCL = IndLCL UCL = IndUCL LCLM = AveLCL UCLM = AveUCL;
RUN;

/* Note: To view the OutReg table, use the PRINT procedure: */
PROC PRINT DATA = work.OutReg;
RUN; 
 
/***************************************************************************************/
/********************************** Example 5.1: in Lecture-1 **************************/ 
/************************* Forest decline because Growth Retardation *******************/
/***************************************************************************************/

/* Forest scientists are concerned with the decline in forest growth throughout the world. One
aspect of this decline is the possible effect of emissions from coal-powered power plants. The
scientists in particular are interested in the pH level of the soil and the resulting impact on tree
growth delay. The forest scientists then want to determine impact on tree growth as the soil
becomes more acidic. An index of growth delay is constructed from the various measurements
taken on the trees with a high value indicating greater delay in tree growth. A higher value of
soil pH indicates a more acidic soil. 20 stands which are exposed to the power plant emissions
are selected for study. */ 


/* First, create the dataset in SAS */ 
/* Note: The @@ allows us to enter more than one observation on the same line. */ 
DATA GrowDelay;
	ATTRIB ID LABEL = "Stand";
	ATTRIB X LABEL = "Average Soil pH";
	ATTRIB Y LABEL = "Growth Delay Index";
	INPUT ID X Y @@;
	DATALINES;
	1 3.3 17.78 2 3.4 21.59 3 3.4 23.84 4 3.5 15.13 
	5 3.6 23.45 6 3.6 20.87 7 3.7 17.78 8 3.7 20.09 
	9 3.8 17.78 10 3.8 12.46 11 3.9 14.95 12 4.0 15.87
	13 4.1 17.45 14 4.2 14.35 15 4.3 14.64 16 4.4 17.25
	17 4.5 12.57 18 5.0 7.15 19 5.1 7.50 20 5.2 4.34
	;
RUN;

/* 	By enabling ODS graphics, we do not need to use the PLOT statement in the REG procedure. */ 
ODS GRAPHICS ON; 

/* 	Note: How did we know earlier what the names of all the outputs were? 
	(E.g., How did we know it was called "Residual"? Why not "Resid" or "Res"?)
	ANSWER: We can turn ODS TRACE on, and the names of all the outputs will be displayed 
	in the log.
*/ 
ODS TRACE ON; 

/* Use the REG procedure to find the LSE */ 
/* Note: The OUTEST option allows us to create a data set (called ParemData, here) that contains 
parameter estimates and other model fit summary statistics. */ 
PROC REG DATA = work.GrowDelay OUTEST = ParemData;
	MODEL Y = X / CLB;
	OUTPUT OUT = GrowPred RESIDUAL = Residual PREDICTED = Fitted;
RUN;

/* Place the regression equation in a macro variable. */
DATA _NULL_;
   SET PAREMDATA;
   CALL SYMPUT("eqn", "Growth Delay = " ||Intercept|| " + " ||X|| " * Soil pH");
RUN;
/* We can now use a %PUT statement to print out the macro variable. */ 
%PUT The regression equation is &eqn; 

ODS PDF FILE = "&path.\ScatterPlot.pdf";
ODS GRAPHICS / RESET WIDTH = 600px HEIGHT = 400px IMAGENAME = "Regression" IMAGEFMT = gif;
PROC SGPLOT DATA = work.GrowDelay;
   REG X = X Y = Y / CLM DATALABEL;
   /* The following INSET statement can be used as */ 
   /* an alternative to the FOOTNOTE statement */
   /* inset "&eqn" / position=bottomleft;  */
   FOOTNOTE1 j = l "Regression Equation";
   FOOTNOTE2 j = l "&eqn";
RUN;
FOOTNOTE;
ODS PDF CLOSE;

/* Find the correlation */
PROC CORR DATA = GrowDelay;
	VAR X Y;
RUN;

/* Check the normality assumption */
PROC CHART DATA = GrowPred;
	VBAR Residual;
RUN;

/*Or*/
PROC SGPLOT DATA = work.GrowPred;
   HISTOGRAM Residual / FILLATTRS = graphdata1 TRANSPARENCY = 0.7 BINSTART = 40 /*binwidth=10*/;
   DENSITY Residual / LINEATTRS = graphdata1;
   HISTOGRAM Y / FILLATTRS = graphdata2 TRANSPARENCY = 0.5 BINSTART = 40 /*binwidth=10*/;
   DENSITY Y / LINEATTRS = graphdata2;
   KEYLEGEND / LOCATION = inside POSITION = topright NOBORDER ACROSS = 2;
   YAXIS GRID;
   XAXIS DISPLAY = (nolabel) /*values=(0 to 300 by 50)*/;
RUN;

/**************************** Predict values Find CI and PI ****************************/
/***************************************************************************************/
PROC SQL;
	CREATE TABLE To_Predict_Delay AS 
		SELECT *
		FROM GrowDelay;
	INSERT INTO To_Predict_Delay
		VALUES (21,4.0,.)
		VALUES (22,6.5,.);
QUIT;

PROC REG DATA = work.To_Predict_Delay;
	MODEL Y = X / CLB CLI CLM;
	OUTPUT OUT = GrowPred1 RESIDUAL = Residual PREDICTED = Fitted LCL = IndLCL UCL = IndUCL LCLM = AveLCL UCLM = AveUCL;
RUN;

/************************************ Lack of fit test *********************************/
/***************************************************************************************/
ODS GRAPHICS OFF;
Data Heat;
	ATTRIB X LABEL="Outdoor Temperature";
	ATTRIB Y LABEL="Heat Loss";
	INPUT X Y @@;
	DATALINES;
	20 86 20 80 20 77
	40 78 40 84 40 75
	60 33 60 38 60 43 
	;
RUN;

PROC REG DATA = work.Heat OUTEST = PAREMDATA NOPRINT;
	MODEL Y = X;
RUN;

DATA _NULL_;
   SET PAREMDATA;
   CALL SYMPUT("eqn", "HeatLoss = " ||Intercept|| " + " ||X|| " * Temperature");
RUN;

PROC SGPLOT DATA = work.Heat;
   REG X = X Y = Y / DATALABEL;
   FOOTNOTE1 j=l "Regression Equation";
   FOOTNOTE2 j=l "&eqn";
RUN;
FOOTNOTE;

PROC REG DATA = work.Heat;
	MODEL Y = X / CLB LACKFIT I;
	OUTPUT OUT = HeatResidual RESIDUAL = Residual PREDICTED = Fitted;
RUN;
